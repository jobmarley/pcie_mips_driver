/*
 Copyright (C) 2022 jobmarley

 This file is part of pcie_mips_driver.

 This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

 You should have received a copy of the GNU General Public License along with Foobar. If not, see <https://www.gnu.org/licenses/>.
 */

/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"
#include "xdma_registers.h"
#include "Dma.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, pciemipsdriverCreateDevice)
#endif

NTSTATUS
pciemipsdriverCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);


    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfDeviceCreate failed");
        return status;
    }

	//
	// Get a pointer to the device context structure that we just associated
	// with the device object. We define this structure in the device.h
	// header file. DeviceGetContext is an inline function generated by
	// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
	// This function will do the type checking and return the device context.
	// If you pass a wrong object handle it will return NULL and assert if
	// run under framework verifier mode.
	//
	deviceContext = DeviceGetContext(device);

	//
	// Initialize the context.
	//

	//
	// Create a device interface so that applications can find and talk
	// to us.
	//
	status = WdfDeviceCreateDeviceInterface(
		device,
		&GUID_DEVINTERFACE_pciemipsdriver,
		NULL // ReferenceString
	);

    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfDeviceCreateDeviceInterface failed");
        return status;
    }

	//
	// Initialize the I/O Package and any Queues
	//
	status = pciemipsdriverQueueInitialize(device);

    // create DMA enabler
    WDF_DMA_ENABLER_CONFIG dma_enabler_config;
    WDF_DMA_ENABLER_CONFIG_INIT(&dma_enabler_config, WdfDmaProfileScatterGather64, 0xFFFFFFFF);
    status = WdfDmaEnablerCreate(device, &dma_enabler_config, NULL, &deviceContext->DmaEnabler);
    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfDmaEnablerCreate failed");
        return status;
    }

    // Lets just use a single transation object
    status = WdfDmaTransactionCreate(deviceContext->DmaEnabler, WDF_NO_OBJECT_ATTRIBUTES, &deviceContext->DmaTransaction);
    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfDmaTransactionCreate failed");
        return status;
    }

    // Create an interrupt for MSI
    WDF_INTERRUPT_CONFIG interrupt_config;
    WDF_INTERRUPT_CONFIG_INIT(&interrupt_config, &pciemipsdriverInterruptISR, &pciemipsdriverInterruptDPC);
    status = WdfInterruptCreate(device, &interrupt_config, WDF_NO_OBJECT_ATTRIBUTES, &deviceContext->Interrupt);
    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfInterruptCreate failed");
        return status;
    }
    WDF_COMMON_BUFFER_CONFIG buffer_config;
    WDF_COMMON_BUFFER_CONFIG_INIT(&buffer_config, 0x1000);
    status = WdfCommonBufferCreateWithConfig(deviceContext->DmaEnabler, 0x1000, &buffer_config, WDF_NO_OBJECT_ATTRIBUTES, &deviceContext->SgCommonBuffer);
    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "WdfCommonBufferCreate failed");
        return status;
    }

    deviceContext->SgBufferPhysicalAddress = WdfCommonBufferGetAlignedLogicalAddress(deviceContext->SgCommonBuffer);
    deviceContext->SgBufferVirtualAddress = WdfCommonBufferGetAlignedVirtualAddress(deviceContext->SgCommonBuffer);
    
    return status;
}

